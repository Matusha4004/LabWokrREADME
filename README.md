# Лабораторная 1

## Отрабатываемый материал

Инкапсуляция, сокрытие, композиция, полиморфизм

## Цель

Освоить основные принципы ООП, применить на практике знания о работе с объектно-ориентированным кодом на C#

## Задание

- Реализовать объектную модель симулятора транспортного маршрута поездов
- Покрыть полученное решение модульными тестами

## Формулировка

В некотором абстрактном городе был запущен проект по строительству транспортной системы использующей поезда на магнитной
подушке. Для сокращения расходов на эксплуатацию системы, было принято решение использовать автоматизированные
транспортные маршруты, самостоятельно контролирующие передвижения поездов без необходимости нанимать машинистов.
В рамках проектирования данной транспортной системы, возникла необходимость моделирования этих транспортных
маршрутов, для того чтобы удостовериться в корректности их работы и предотвратить инциденты.

Вам как разработчикам была поставлена задача разработать данный симулятор.

## Функциональные требования

Основной информацией, которую должен выдавать ваш симулятор, является результат прохождения маршрута. Данный результат
может быть как успешным, так и нет ([подробнее](#станции)). Также результат должен содержать информацию об общем
времени, затраченном для прохождения пути.

### Поезда

В рамках симулятора поезда имеют следующие атрибуты:

- масса
- скорость
- ускорение
- максимально допустимая сила

Поезда должны уметь рассчитывать время прохождения определённого расстояния, эти вычисления должны основываться на
текущей скорости и ускорении поезда. Скорость и ускорение поезда изначально имеют нулевые значения.

Также к поездам можно приложить какую-либо силу, это происходит
на [силовых магнитных путях](#силовые-магнитные-пути). Приложение к поезду силы приводит к перерасчёту его
ускорения (рассчитываемого по формуле $ускорение={сила \over масса}$). При попытке приложить к поезду силу, превышающую
максимально допустимую, операция возвращает неудачу.

В данном симуляторе используются крайне упрощённые законы физики – поезда двигаются по законам материальной точки.

Поездам также задаётся точность – временной промежуток, на который разбиваются вычисления итогового времени прохождения
расстояния. Соответственно расчёт итогового времени прохождения расстояния должны происходить итеративно.

Каждая итерация расчёта времени предполагает расчёт результирующей скорости

$$результирующая\ скорость = текущая\ скорость + ускорение * точность$$

И расчёт пройденного расстояния

$$пройденное\ расстояние = результирующая\ скорость * точность$$

После расчёта пройденного расстояния, оно вычитается из оставшегося. Итерации продолжаются пока оставшееся расстояние не
будет меньше или равно нулю.

Следует принимать во внимание граничные случаи прохождения расстояния, когда поезд не имеет ни скорости, ни ускорения,
или же когда скорость поезда становится отрицательной. В таких случаях прохождение расстояния завершается неудачей.

### Участок маршрута

Маршрут транспортной системы состоит из участков, они представляют собой магнитные пути по которым могут передвигаться
поезда. Существуют несколько различных участков маршрута и поведение поезда на них отличается друг от друга.

Результатом прохождения поезда по участку пути, может являться либо успех, содержащий время прохождения, либо неудача.

#### Обычные магнитные пути

Обычные магнитные пути имеют продолжительность, которая влияет на время их прохождения. Успех прохождения через такие
пути определяется успехом прохождения поездом их расстояния.

#### Силовые магнитные пути

Силовые магнитные пути, как следует из названия, прикладывают к поезду силу на всём своём протяжении, эта сила может
быть как положительной, так и отрицательной (в таком случае поезд будет замедляться).

Так же как и обычные, силовые пути имеют продолжительность, влияющую на время их прохождения и успех их прохождения
определяется успехом прохождения поедом их расстояния.

#### Станции

Ещё одним видом участка маршрута являются станции. Когда поезд прибывает на станцию, происходит высадка и посадка
пассажиров. Факторы загруженности на высадку и посадку влияют на время прохождения станции поездом.

На станциях расположены силовые модули, тормозящие поезда до их остановки и разгоняющие их до скорости, с которой поезд
на неё прибыл. Но возможности этих модулей ограничены, станции имеют лимит по скорости приходящего поезда, поезда,
приходящие со скоростью, превышающую её не будут остановлены, что соответственно обозначает неудачу прохождения данного
участка маршрута.

### Маршрут

Маршрут является набором его участков и отвечает за логику прохождения поезда по этим участкам, а также обработку
результатов этих прохождений.

По завершению маршрута, поезд должен остановиться, для этого маршрут имеет механику схожую со станциями. На конце
маршрута расположены силовые модули также имеющие лимиты по скорости. Поэтому, если после прохождения всех участков
маршрута, поезд имеет скорость, превышающую допустимую – прохождение пути будет неудачно.

## Нефункциональные требования

- Ваша реализация должна соответствовать основным принципам ООП, вы должны корректно инкапсулировать логику и сокрывать
  не нужные извне состояния.
- Типы маршрута и его участков должны быть иммутабельными
- В реализации не должны использоваться исключения при обнаружении неудачных исходов подразумеваемых бизнес логикой

## Тестовые сценарии

### Сценарий 1

Маршрут:

- силовой путь, ускоряющий поезд до допустимой скорости маршрута
- обычный путь

Результат: успех

### Сценарий 2

Маршрут:

- силовой путь, ускоряющий поезд более допустимой скорости маршрута
- обычный путь

Результат: неудача

### Сценарий 3

Маршрут:

- силовой путь, ускоряющий поезд до допустимой скорости маршрута и станции
- обычный путь
- станция
- обычный путь

Результат: успех

### Сценарий 4

Маршрут:

- силовой путь, ускоряющий поезд более допустимой скорости станции
- станция
- обычный путь

Результат: неудача

### Сценарий 5

Маршрут:

- силовой путь, ускоряющий поезд более допустимой скорости маршрута, но до допустимой скорости станции
- обычный путь
- станция
- обычный путь

Результат: неудача

### Сценарий 6

Маршрут:

- силовой путь, ускоряющий поезд более допустимой скорости станции
- обычный путь
- силовой путь, замедляющий поезд до допустимой скорости станции
- станция
- обычный путь
- силовой путь, ускоряющий поезд более допустимой скорости маршрута
- обычный путь
- силовой путь, замедляющий поезд до допустимой скорости маршрута

Результат: успех

### Сценарий 7

Маршрут:

- обычный путь

Результат: неудача

### Сценарий 8

Маршрут:

- силовой путь длины X, прикладывающий силу Y
- силовой путь длины X, прикладывающий силу -2Y

Результат: неудача

## Определение готовности

- Реализованы все функциональные и нефункциональные требования
- Реализованы все тестовые сценарии, реализация успешно проходит эти тесты


# Лабораторная 2

## Отрабатываемый материал

Основные принципы ООП, SOLID, GRASP, порождающие паттерны

## Цель

Отработать реализацию порождающих паттернов, применить их совместно с ранее изученным материалом.

## Задание

- реализовать модель конструктора образовательных программ
- покрыть полученное решение тестами

## Формулировка

Некоторый абстрактный университет проектирует систему для формирования и редактирования образовательных программ. Вам
необходимо спроектировать предметную область для реализации данного функционала.

В системе присутствуют: пользователи, лабораторные, лекционные материалы, критерии оценивания, предметы, сами
образовательные программы.

## Функциональные требования

### Пользователь

- Имеет идентификатор и имя
- Привязан к последующим создаваемым сущностям в качестве автора

### Лабораторная работа

- Имеет: идентификатор, наименование, описание, критерии оценивания, количество баллов
- Также имеет автора
- Лабораторную работу можно создать на основе уже существующей, в таком случае она должна хранить идентификатор
  лабораторной, взятой за основу
- Лабораторная может быть изменена, но сделать это может только её автор, при этом количество баллов неизменно

### Лекционные материалы

- Имеют: идентификатор, наименование, краткое описание, контент (строковый)
- Также имеют автора
- Лекционные материалы можно создать на основе уже существующих, в таком случае они должны хранить идентификатор
  лекционных материалов, взятых за основу
- Лекционные материалы могут быть изменены, но сделать это может только их автор

### Предмет

- Имеет: идентификатор, название, список лабораторных работ, список лекционных материалов
- Также имеет автора
- К предметам привязан зачётный формат: экзамен или зачет
- В случае, когда предмет имеет экзамен, он должен содержать количество баллов
- В случае, когда предмет имеет зачёт, он должен содержать информацию о минимальном количестве баллов, необходимых для
  получения этого зачёта
- Предмет можно создать на основе уже существующих, в таком случае он должен хранить идентификатор предмета, взятого за
  основу
- Предмет может быть изменён, но сделать это может только его автор, при этом списко лаборторных работ поменять нельзя, как и количество баллов за экзамен
- Суммарное количество баллов предмета должно ровнятся 100

### Образовательная программа

- Имеет: идентификатор, название, список предметов
- Предметы должны быть привязаны к определённым семестрам
- Также имеет ответственное лицо, руководителя программы

## Нефункциональные требования

- Реализации создания сущностей на основе предыдущих должны использовать различные порождающие паттерны
- Для сущностей должны быть реализованы репозитории, хранящие созданные объекты и осуществляющие поиск по их
  идентификаторам
- При использовании абстракций, не должно быть необходимости указывать автора каждый раз при сборке новых сущностей

> Репозиторий – тип, ответсвенный за хранение, добавление и поиск каких-либо сущностей. В данной лабораторной вам необхоимо сделать in-memory реализацию (основанную на листе или словаре, например), которая просто позволяет отслеживать определённые сущности и потом их искать.

## Тестовые сценарии

- Попытки изменения сущностей не автором – возвращают ошибки
- После создания сущностей на основе существующих, копии должны содержать идентификаторы исходника
- При создании предмета, с количеством баллов не равное 100 – возвращается ошибка

## Определение готовности

- реализованы все функциональные и не функциональные требования
- реализованы все необходимые юнит-тесты
- в реализации лабораторной используются порождающие паттерны
- реализация не нарушает принципы SOLID, следует основным концепциям ООП

# Лабораторная 3

# Отрабатываемый материал

Основные принципы ООП, GRASP, SOLID, порождающие паттерны, структурные паттерны, mocking.

# Цель

Отработать реализацию структурных паттернов, применить их совместно с ранее изученным материалом.

# Задание

- Реализовать объектную модель корпоративной системы распределения сообщений, используя на практике отрабатываемый
  теоретический материал
- Покрыть полученное решение функциональными авто-тестами

# Формулировка

Некоторая компания разрабатывает корпоративную систему распределения сообщений. Предметная область, которую компания
автоматизирует, имеет сложный механизм формирования адресатов, а так же набор различных конечных точек для сообщений.

# Функциональные требования

## Сообщение

- Имеет заголовок
- Имеет тело
- Имеет уровень важности

## Топик

- Имеет название
- Имеет адресатов
- В топик можно отправить сообщение, он должен передать его адресату

## Адресат

- В адресат можно передать сообщение
- Адресаты бывают нескольких видов
    - Адресат-пользователь
      Передает сообщение пользователю корпоративной системы
    - Адресат-мессенджер
      Отправляет сообщение используя сторонний мессенджер
    - Адресат-дисплей
      Выводит сообщение на какое-либо физическое устройство отображения
    - Адресат-группа
      Содержит в себе несколько адресатов, передаёт каждому из них полученные сообщения
- Необходимо иметь возможность фильтровать сообщения для конкретных адресатов по их уровню важности
- Необходимо иметь возможность логгировать сообщения, получаемые конкретным адресатом

## Пользователь

- Является конечной точкой сообщения
- Пользователь может иметь некоторые атрибуты (не обязательно для контекста лабораторной)
- Должна быть возможность отправить пользователю сообщение
- Пользователь должен отслеживать полученные сообщения, и их статус (прочитано, не прочитано) (статус сообщения
  существует только в контексте пользователя)
- Пользователь должен иметь возможность отметить сообщение прочитанным \
  Отметить такое сообщение можно только в статусе не прочитано, попытка отметить прочитанное сообщение должна
  обрабатываться

## Мессенджер

- Является конечной точкой сообщения
- Должен иметь возможность выводить текст
  Для целей лабораторной можно просто выводить текст в консоль с припиской “мессенджер”

## Дисплей

- Является конечной точкой сообщения
- Должен иметь возможность выводить текст заданного цвета
  Дисплей должен держать лишь одно сообщение, поэтому перед выводом его необходимо очищать

## Дисплей-драйвер

- Должен иметь возможность очистить вывод
- Должен иметь возможность задать цвет выводимого текста
- Должен иметь возможность записать текст

# Не функциональные требования

- Реализация логгирования должна быть тестируемой
  например, проверить вывод на консоль при вызове некоторых поведений в авто-тестах - невозможно \
  нужно иметь возможность реализовать в тестах mock-тип, который будет вести счётчик вызовов
- Реализация мессенджера и дисплея должна быть тестируемой
- Реализация мессенджера и дисплея должна быть изолирована \
  Эти реализации не должны иметь явной или неявной зависимости на логику доставки сообщений, ведь они являются
  сторонними интеграциями \
  Их реализации должны находиться в отдельных папках
- Вывод на дисплей должен быть реализован как вывод на консоль так и вывод в файл
  Для упрощения окраски теста можно использовать сторонний NuGet пакет

# Definition of done

- Реализованы все функциональные требования
- Реализация соответствует всем не функциональным требованиям
- Реализация не нарушает принципы SOLID, следует основным принципам ООП
- Использованы структурные паттерны
- Корректно использован порождающий паттерн
- Реализованы все тест-кейсы

# Test cases

- При получении сообщения пользователем, оно сохраняется в статусе “не прочитано”
- При попытке отметить сообщение пользователя в статусе “не прочитано” как прочитанное, оно должно поменять свой статус
- При попытке отметить сообщение пользователя в статусе “прочитано” как прочитанное, должна вернуться ошибка
- При настроенном фильтре для адресата, отправленное сообщение, не подходящее под критерии важности - до адресата дойти
  не должно (в данном тесте необходимо использовать моки)
- При настроенном логгировании адресата, должен писаться лог, когда приходит сообщение (в данном тесте необходимо
  использовать моки)
- При отправке сообщения в месенджер, его реализация должна производить ожидаемое значение (в данном тесте необходимо
  использовать моки)
- Добавляются два адресата-пользователя (для одного пользователя), для одного из них настраивается фильтр важности, при
  попытке отправить сообщение с важностью ниже настроенной – пользователь получает значение единожды.

---




# Лабораторная 4

# Отрабатываемый материал

SOLID, поведенческие, структурные, порождающие паттерны

# Цель

Проверить освоение студентом принципов SOLID, паттернов проектирования.

# Задание

Разработать приложение для взаимодействия и управления файловой системой.

# Функциональные требования

- Навигация по дереву файловой системы (относительные и абсолютные пути)
- Просмотр содержимого каталога в консоли
- Просмотр содержимого файлов в консоли
- Перемещение файлов
- Копирование файлов
- Удаление файлов
- Переименование файлов
- Консольный механизм взаимодействия с приложением
- Реализация операций для локальной файловой системы

# Не функциональные требования

- Система должна поддерживать взаимодействие посредством консольных команд, имеющих флаги.
- Логика работы системы не должна быть привязана к обработке консольных команд.
- Система должна поддерживать возможность расширения параметров консольных команд.
- Обработка команд не должна быть привязана к консоли.
- Система не должна быть завязана на локальную файловую систему.
- Вывод содержимого каталога должен быть параметризован глубиной выборки (значение по умолчанию - 1)
- Вывод системного каталога должен быть в виде дерева.
- Параметры выводимого дерева (символы обозначающие файл, папку, символы используемые для отступов должны быть
  программно параметризуемыми).
- Логика вывода содержимого каталога не должна быть завязана на консоль.
- Логика вывода содержимого файла не должна быть завязана на консоль.
- Система должна адекватно обрабатывать случаи коллизий имён.
- Система должна уметь переключаться между файловыми системами (например смена диска C, на диск D).
- После вывода результата на консольный интерфейс, программа должна ожидать ввод следующей команды.
- Для реализации системы нельзя использовать какие-либо сторонние библиотеки

# Глоссарий

- Относительный путь - путь от текущего положения, выбранного в системе
- Абсолютный путь - путь от положения, в которое изначально было сделано подключение

# Семантика команд

- connect [Address] [-m Mode] \
  Address - абсолютный путь в подключаемой файловой системе \
  Mode - режим файловой системы (требуется реализовать только локальную ФС, значение `local`)
- disconnect \
  Отключается от файловой системы
- tree goto [**Path**] \
  **Path** - относительный или абсолютный путь до каталога в файловой системе
- tree list {-d **Depth**} \
  **Depth** - параметр, определяющий глубину выборки, должен объявляться флагом `-d`
- file show [**Path**] {-m **Mode**} \
  **Path** - относительный или абсолютный путь до файла \
  **Mode** - режим вывода файла (требуется реализовать только консольный, значение `console`)
- file move [**SourcePath**] [**DestinationPath**] \
  **SourcePath** - относительный или абсолютный путь до перемещаемого файла \
  **DestinationPath** - относительный или абсолютный путь до директории, куда файл должен быть перемещён
- file copy [**SourcePath**] [**DestinationPath**] \
  **SourcePath** - относительный или абсолютный путь до копируемого файла \
  **DestinationPath** - относительный или абсолютный путь до директории, куда файл должен быть скопирован
- file delete [**Path**] \
  **Path** - относительный или абсолютный путь до удаляемого файла
- file rename [**Path**] [**Name**] \
  **Path** - относительный или абсолютный путь до изменяемого файла \
  **Name** - новое имя файла

# Test cases

- Протестировать парсер команд: обработка консольных команд с аргументами должна создавать команду корректного типа с
  корректными аргументами

# Definition of done

- Реализованы все функциональные требования
- Реализация соответствует всем не функциональным требованиям
- Реализация не нарушает принципы SOLID, следует основным принципам ООП
- Реализован консольный интерфейс работы с приложением






# Лабораторная 5

# Отрабатываемый материал

Многослойные архитектуры, паттерны

# Цель

Проверить освоение студентом многослойных архитектур

# Задание

Реализовать систему банкомата

# Функциональные требования

- создание счета
- просмотр баланса счета
- снятие денег со счета
- пополнение счета
- просмотр истории операций

# Не функциональные требования

- интерактивный консольный интерфейс
- возможность выбора режима работы (пользователь, администратор)
    - при выборе пользователя должны быть запрошены данные счета (номер, пин)
    - при выборе администратора должен быть запрошен системный пароль
        - при некорректном вводе пароля - система прекращает работу
- системный пароль должен быть параметризуем
- при попытке выполнения некорректных операций, должны выводиться сообщения об ошибке
- данные должны быть персистентно сохранены в базе данных (PostgreSQL)
- использование каких-либо ORM библиотек - запрещено
- приложение должно иметь хексагональную архитектуру
    - опционально: можно реализовать луковую архитектуру с богатой доменной моделью.

# Test cases

- снятие денег со счёта
    - при достаточном балансе проверить что сохраняется счёт с корректно обновлённым балансом
    - при недостаточном балансе сервис должен вернуть ошибку
- пополнение счёта
    - проверить что сохраняется счёт с корректно обновлённым балансом

данные тесты должны проверять бизнес логику, они не должны как-либо зависить от базы данных или консольного
представления.

в данных тестах необходимо использовать моки репозиториев.

# Ссылки

https://spectreconsole.net/

https://www.npgsql.org/

https://www.nuget.org/packages/NSubstitute

Так же можете воспользоваться вспомогательной библиотекой, содержащей расширения для более удобного задания параметров
команд.

https://github.com/itmo-is-dev/platform/tree/master/src/Itmo.Dev.Platform.Postgres

https://www.nuget.org/packages/Itmo.Dev.Platform.Postgres

### Для желающих попробовать DependencyInjection

https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-usage (очень плохие практики в примерах
кода, использовать только как шоукейс технологии)

